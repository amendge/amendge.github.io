<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://github.com/amendge/amendge.github.io</id>
    <title>Amend</title>
    <updated>2021-04-08T08:58:22.061Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://github.com/amendge/amendge.github.io"/>
    <link rel="self" href="https://github.com/amendge/amendge.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://github.com/amendge/amendge.github.io/images/avatar.png</logo>
    <icon>https://github.com/amendge/amendge.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Amend</rights>
    <entry>
        <title type="html"><![CDATA[【实践】基于Prometheus函数的动态告警规则]]></title>
        <id>https://github.com/amendge/amendge.github.io/post/shi-jian-ji-yu-prometheus-han-shu-de-dong-tai-gao-jing-gui-ze/</id>
        <link href="https://github.com/amendge/amendge.github.io/post/shi-jian-ji-yu-prometheus-han-shu-de-dong-tai-gao-jing-gui-ze/">
        </link>
        <updated>2021-02-23T16:01:56.000Z</updated>
        <summary type="html"><![CDATA[<p>对于监控来说，告警规则是告警检测发出的基本，当前市面上几乎所有的开源告警软件提供的规则基本上都是静态告警规则或者范围告警</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于监控来说，告警规则是告警检测发出的基本，当前市面上几乎所有的开源告警软件提供的规则基本上都是静态告警规则或者范围告警</p>
<!-- more -->
<h1 id="先看下官方文档">先看下官方文档</h1>
<h2 id="官方函数英文注释">官方函数英文注释</h2>
<pre><code>Holt-Winters is similar to a weighted moving average, where historical data has exponentially less influence on the current data.
Holt-Winter also accounts for trends in data. The smoothing factor (0 &lt; sf &lt; 1) affects how historical data will affect the current data. A lower smoothing factor increases the influence of historical data. The trend factor (0 &lt; tf &lt; 1) affects
how trends in historical data will affect the current data. A higher trend factor increases the influence.
of trends. Algorithm taken from https://en.wikipedia.org/wiki/Exponential_smoothing titled: &quot;Double exponential smoothing&quot;.
</code></pre>
<p>中文注释：<br>
Holt-Winters类似于加权移动平均，其中历史数据对当前数据的影响呈指数级减小。<br>
Holt-Winters也解释了数据的趋势。平滑因子(0 &lt; sf &lt; 1)影响历史数据对电流的影响<br>
数据。平滑因子越低，历史数据的影响越大。趋势因子(0 &lt; tf &lt; 1)影响<br>
历史数据的趋势将如何影响当前数据。趋势因子越高，影响越大的趋势。算法取自https://en.wikipedia.org/wiki/Exponential_smoothing标题:“双指数平滑”</p>
<h2 id="官方函数代码">官方函数代码</h2>
<pre><code>func funcHoltWinters(vals []parser.Value, args parser.Expressions, enh *EvalNodeHelper) Vector {
	samples := vals[0].(Matrix)[0]

	// The smoothing factor argument.
	sf := vals[1].(Vector)[0].V

	// The trend factor argument.
	tf := vals[2].(Vector)[0].V

	// Sanity check the input.
	if sf &lt;= 0 || sf &gt;= 1 {
		panic(errors.Errorf(&quot;invalid smoothing factor. Expected: 0 &lt; sf &lt; 1, got: %f&quot;, sf))
	}
	if tf &lt;= 0 || tf &gt;= 1 {
		panic(errors.Errorf(&quot;invalid trend factor. Expected: 0 &lt; tf &lt; 1, got: %f&quot;, tf))
	}

	l := len(samples.Points)

	// Can't do the smoothing operation with less than two points.
	if l &lt; 2 {
		return enh.Out
	}

	var s0, s1, b float64
	// Set initial values.
	s1 = samples.Points[0].V
	b = samples.Points[1].V - samples.Points[0].V

	// Run the smoothing operation.
	var x, y float64
	for i := 1; i &lt; l; i++ {

		// Scale the raw value against the smoothing factor.
		x = sf * samples.Points[i].V

		// Scale the last smoothed value with the trend at this point.
		b = calcTrendValue(i-1, tf, s0, s1, b)
		y = (1 - sf) * (s1 + b)

		s0, s1 = s1, x+y
	}

	return append(enh.Out, Sample{
		Point: Point{V: s1},
	})
}
</code></pre>
<h2 id="calctrendvalue注释">calcTrendValue注释</h2>
<pre><code> Calculate the trend value at the given index i in raw data d.
This is somewhat analogous to the slope of the trend at the given index.
The argument &quot;tf&quot; is the trend factor.
The argument &quot;s0&quot; is the computed smoothed value.
The argument &quot;s1&quot; is the computed trend factor.
The argument &quot;b&quot; is the raw input value.
</code></pre>
<p>中文注释：</p>
<ul>
<li>计算原始数据d中给定索引i处的趋势值。</li>
<li>这有点类似于给定指数处趋势的斜率。</li>
<li>参数“tf”是趋势因子。</li>
<li>参数&quot;s0&quot;是计算得到的平滑值。</li>
<li>参数&quot;s1&quot;是计算出来的趋势因子。</li>
<li>参数“b”是原始输入值。</li>
</ul>
<h2 id="calctrendvalue代码">calcTrendValue代码</h2>
<pre><code>func calcTrendValue(i int, tf, s0, s1, b float64) float64 {
	if i == 0 {
		return b
	}
	x := tf * (s1 - s0)
	y := (1 - tf) * b
	return x + y
}
</code></pre>
<h2 id="代码观后感">代码观后感</h2>
<p>对于我来说这个代码看的大概就是一个算法的思路，如何基于当前给定的序列值,再根据平滑因子、历史数据比重去算一个趋势值</p>
<h1 id="实践">实践</h1>
<h2 id="基于网络流量做突增突降异常检测">基于网络流量做突增突降异常检测</h2>
<p>根据机器入口流量做异常突增突降告警,因为流量对于现网来说是一个周期性变化的值，根据现网请求数据的稳定性，在一定的时间内流量时趋于一定规律进行下降和上升，如果有大比例的下降或上升就回有问题<br>
1.Prometheus查询流量语句</p>
<pre><code>sum(irate(node_network_receive_bytes_total{app=&quot;01&quot;,idc=&quot;bj&quot;,group=&quot;test&quot;,device=~&quot;eth1&quot;}[5m] offset 1m)*8)by(device)
</code></pre>
<p>2.Prometheus record offset 5m</p>
<pre><code>groups:
- name: instance_net_record_rules
  rules:
  - record: net_offset_5m:node_network_receive:bj_test_01
    expr: sum(irate(node_network_receive_bytes_total{app=&quot;01&quot;,idc=&quot;bj&quot;,group=&quot;test&quot;,device=~&quot;eth1&quot;}[1m] offset 5m)*8)by(device)
</code></pre>
<p>正式的告警规则<br>
中文注释:app=&quot;01&quot;,idc=&quot;bj&quot;,group=&quot;test&quot;的机器eth1网卡入口流量和五分钟前流量对比 波动超30%</p>
<pre><code>abs(sum(irate(node_network_receive_bytes_total{app=&quot;01&quot;,idc=&quot;bj&quot;,group=&quot;test&quot;,device=~&quot;eth1&quot;}[1m])*8)by(device) - holt_winters(net_offset_5m:node_network_receive:bj_test_01[1h],0.5,0.8))/1024^2 &gt; holt_winters(net_offset_5m:node_network_receive:bj_test_01[1h],0.5,0.8)*0.3/1024^2 &gt;5
</code></pre>
<p>拆分解析:</p>
<ul>
<li>abs是为了去正整数</li>
<li>holt_winters(net_offset_5m:node_network_receive:bj_test_01[1h],0.5,0.8))/1024^2 根据一分钟前所得的数据进行平滑拟合除当前大概的数据</li>
<li>1024^2 流量单位转换</li>
<li>大于5 为了去除最低谷时流量较低告警<br>
4.对比<br>
holt_winters(net_offset_5m:node_network_receive:bj_test_01[1h],0.5,0.8)等同于<br>
sum(irate(node_network_receive_bytes_total{app=&quot;01&quot;,idc=&quot;bj&quot;,group=&quot;test&quot;,device=~&quot;eth1&quot;}[1m])*8)by(device)<br>
效果图:<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617866977845.png" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【监控】告警聚合|告警召回功能实现]]></title>
        <id>https://github.com/amendge/amendge.github.io/post/jian-kong-gao-jing-ju-he-orgao-jing-zhao-hui-gong-neng-shi-xian/</id>
        <link href="https://github.com/amendge/amendge.github.io/post/jian-kong-gao-jing-ju-he-orgao-jing-zhao-hui-gong-neng-shi-xian/">
        </link>
        <updated>2021-01-13T13:40:14.000Z</updated>
        <summary type="html"><![CDATA[<pre><code>    监控系统发展的过程中，当你的系统监控规则和数据比较完善的时候或者覆盖面比较高的情况下，在发生问题时就会产生大量的告警信息或者持续的告警，在告警的持续阶段从低-中-高和相关的告警都会出现多次。所以在告警发生时对于关键信息的提取尤为关键
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code>    监控系统发展的过程中，当你的系统监控规则和数据比较完善的时候或者覆盖面比较高的情况下，在发生问题时就会产生大量的告警信息或者持续的告警，在告警的持续阶段从低-中-高和相关的告警都会出现多次。所以在告警发生时对于关键信息的提取尤为关键
</code></pre>
<!-- more -->
<h1 id="针对应用告警">针对应用告警:</h1>
<p>我们应用告警主要采用Prometheus，基于Alertmanager做了基于alertname、instance和pod的分组聚合覆盖容器和自定义指标的分组聚合，以及根据定义的级别进行了同组、同机器、同集群高级别静默低级别<br>
参考: https://www.noalert.cn/post/ru-he-yong-yuan-sheng-prometheus-jian-kong-da-gui-mo-kubernetes-ji-qun/</p>
<h1 id="针对业务告警">针对业务告警：</h1>
<p>逻辑架构:<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617864543945.jpg" alt="" loading="lazy"><br>
业务模块:<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617864150672.png" alt="" loading="lazy"><br>
我们的业务告警全部是基于现网日志去做的监控告警分析,现网基本覆盖所有组件的性能日志和业务日志。对于消费链路、消费过程中的问题和打日志的规范问题不做阐述</p>
<h2 id="业务告警规则">业务告警规则：</h2>
<ul>
<li>基于给定的状态码或耗时进行全量日志的比例分析和关键词提取</li>
<li>告警检测时间 默认一分钟</li>
<li>告警检测全量数据默认为type:_doc,部分自定义</li>
<li>告警规则带有业务模块属性</li>
<li>告警规则带有告警推送地址</li>
<li>告警规则带有检测比例属性</li>
</ul>
<h2 id="业务规则模板">业务规则模板</h2>
<pre><code>index: access-xxxx-*
name: aiuiathenaosstimeout
type: percentage_match

percentage_config:
  items:
    高: [5, 100]
    中: [1, 5]
    低: [0.1, 1]
percentage_format_string: &quot;%.3f&quot;
match_min_num: 10
aiui_group: ['aiui-athena-nlu']
minutes: 1

filter:
- term:
    _type: doc
match_bucket_filter:
- terms:
    ret: [11004]
http_post_url: &quot;http://xxxxxxx:8088/alert&quot;
http_post_static_payload:
    subject: 上海-入口-组件名称-11004异常状态码监控
    message: 上海-组件异常ret-11004
</code></pre>
<h2 id="业务告警格式">业务告警格式</h2>
<pre><code class="language-{'match_count':">_group': ['athena', 'aiui-test'], '_level': '低', 'num_matches': 1, 'message': '告警信息二', 'match_percentage': '0.110', 'subject': '告警标
题二'}
</code></pre>
<h1 id="talking-is-cheap-show-me-code">talking is cheap show me code</h1>
<p>##代码环境</p>
<ul>
<li>Python tornado 框架</li>
<li>elastalert<br>
##主体更改</li>
</ul>
<pre><code>AGG_LOOP_MS = 65000  #毫秒
MAX_AGG_SECONDS = 3600 #秒
ALERT_TTL = 90 #秒
EVENT_LOG_FILE =  &quot;./test.log&quot;

now = time.time()
unique_value = str(random.randint(0, 3000000000))
#unique_value = str(random.sample('abcdefghijklmnopqrstuvwxyz0123456789', 8))
logger = EventLogger(EVENT_LOG_FILE)
logger.write(now, &quot;alert&quot;, &quot;merge&quot;, unique_value, ALERT_TTL, json.dumps(data,ensure_ascii=False))
#框架调用
ioloop.PeriodicCallback(cronjob_aggregation, AGG_LOOP_MS).start()
ioloop.IOLoop.current().start()
</code></pre>
<h3 id="event_loggerpy-告警写入和读取">event_logger.py #告警写入和读取</h3>
<pre><code>#!python3
# -*- coding: utf-8 -*-
import json
import os
import pathlib
import requests

TS = 0
EVENT_TYPE = 1
STATUS = 2
UNIQ_VALUE = 3
TTL = 4
MSG = 5
class EventLogger(object):
    file_path = &quot;&quot;
    content = []

    def __init__(self, file_path):
        self.file_path = file_path
        self.read()

    def __del__(self):
        pass

    def write(self, ts, event_type, status, uniq_value, ttl, msg):
        if isinstance(msg, dict):
            msg = json.dumps(msg)
        with open(self.file_path, &quot;a+&quot;) as f:
            ts = int(ts)
            ttl = int(ttl)
            f.write(&quot;{};{};{};{};{};{}\n&quot;.format(ts, event_type, status, uniq_value, ttl, msg))
            self.content.append((ts, event_type, status, uniq_value, ttl, msg))
            print &quot;alert insert ok&quot;

    def read(self):
        if not os.path.isfile(self.file_path):
            pathlib.Path(self.file_path).touch()
        with open(self.file_path, &quot;r&quot;) as f:
            self.content = []
            #for l in f.readlines():
            for l in f.read().splitlines():
                l = l.split(&quot;;&quot;)
                info = l[:MSG]
                info[TS] = int(info[TS])
                info[TTL] = int(info[TTL])
                msg = &quot;;&quot;.join(l[MSG:])
                self.content.append((info + [msg]))
</code></pre>
<h3 id="聚合核心部分">聚合核心部分：</h3>
<pre><code>def cronjob_aggregation():
    logger = EventLogger(EVENT_LOG_FILE)
    content = [x for x in logger.content]
    content.reverse()
    now = time.time()
    left_time = now - MAX_AGG_SECONDS

    msg_to_send = defaultdict(list)
    wechatid_to_send = list()
    already_send_set = dict()
    to_group = 0
    # 获取所有没有发送的聚合消息
    for row in content:
        if row[TS] &lt; left_time:
            break  # 超过支持的最大消息过期时间就不处理了
        if row[EVENT_TYPE] == &quot;alert&quot; and row[STATUS] == &quot;merge&quot; and row[UNIQ_VALUE] not in already_send_set:
            msg_to_send[row[UNIQ_VALUE]].append(row)
        if row[EVENT_TYPE] == &quot;alert&quot; and row[STATUS] == &quot;send&quot; and row[UNIQ_VALUE] not in already_send_set:
            already_send_set[row[UNIQ_VALUE]] = int(row[TTL]) + int(row[TS])  # 标记每个聚合消息的超时时间
        if 'aiui_group' in json.loads(row[MSG]).keys() and row[UNIQ_VALUE] not in already_send_set:
            wechatid_to_send.append(parse_user_info(json.loads(row[MSG]))['id'])
        if 'level' in json.loads(row[MSG]) and row[UNIQ_VALUE] not in already_send_set:
           if json.loads(row[MSG])['level'].encode(&quot;utf-8&quot;) in [&quot;高&quot;,&quot;disaster&quot;]:
              to_group = 1

    # 发送这些消息
    alert_content = ''
    list_alert_content = []
    level_list = []
    for k, v in msg_to_send.items():
        if int(time.time()) &lt;= already_send_set.get(k, 0):
            continue  # 没到超时时间的直接跳过
        msg_decoded = [json.loads(x[MSG]) for x in v]
        list_alert_content += [x[&quot;message&quot;] for x in msg_decoded]
        alert_content = '\n'.join(list_alert_content)
        subject = &quot;[聚合消息] {}&quot;.format(msg_decoded[-1][&quot;subject&quot;])
        logger.write(now, &quot;alert&quot;, &quot;send&quot;, k, v[-1][TTL], json.dumps({&quot;subject&quot;:subject, &quot;message&quot;:alert_content},ensure_ascii=False))
    if msg_to_send.items() and len(msg_to_send.items()) &gt; 1 and to_group == 1:
       subject += ' 共'+str(len(msg_to_send.items())) +'条告警'
       send2tag(subject.encode(&quot;utf-8&quot;),alert_content,'|'.join(wechatid_to_send))
       send2group(subject.encode(&quot;utf-8&quot;),alert_content)
    elif msg_to_send.items() and len(msg_to_send.items()) &gt; 1 and to_group == 0:
       subject += ' 共'+str(len(msg_to_send.items())) +'条告警'
       send2tag(subject.encode(&quot;utf-8&quot;),alert_content,'|'.join(wechatid_to_send))
    else:
       subject = &quot;[业务告警] {}&quot;.format(msg_decoded[-1][&quot;subject&quot;])
       send2tag(subject.encode(&quot;utf-8&quot;),alert_content,'|'.join(wechatid_to_send))
</code></pre>
<p><strong>还可以根据重要的告警级别进行TTL时间内的高级别告警召回，代码如上更改捞取数据和发送规则即可</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【实践】Prometheus日渐增长的内存如何做hash分离]]></title>
        <id>https://github.com/amendge/amendge.github.io/post/shi-jian-prometheus-ri-jian-zeng-chang-de-nei-cun-ru-he-zuo-hash-fen-chi/</id>
        <link href="https://github.com/amendge/amendge.github.io/post/shi-jian-prometheus-ri-jian-zeng-chang-de-nei-cun-ru-he-zuo-hash-fen-chi/">
        </link>
        <updated>2020-12-18T06:32:32.000Z</updated>
        <summary type="html"><![CDATA[<p>Prometheus唯一的缺点就是监控项越来越多的情况下,内存消耗是很大的,如果根据指标项进行搜集分割？</p>
]]></summary>
        <content type="html"><![CDATA[<p>Prometheus唯一的缺点就是监控项越来越多的情况下,内存消耗是很大的,如果根据指标项进行搜集分割？</p>
<!-- more -->
<h1 id="落盘设计">落盘设计：</h1>
<p>Prometheus在数据落盘的流程上进行了一定的考虑。<br>
完整的数据流程应该是:pull-&gt;prometheus-&gt;memory-&gt;wal-&gt;tsdb-&gt;filesystem.<br>
正常的情况下，Prometheus会把最新搜集到的数据放在内存中，针对搜集量较大，metrics内包含较大、较多label的和监控项 time series较多的监控指标来说存在内存里是不太友好的，会占用较高的内存使用，同时内存里面也会存储相对较老还没有落盘的数据。以t0-t1为最新时间，t1-t2为较老时间，t3,t4... 内存中: (t0-t1的series+t1-t2的series)<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617867267806.png" alt="" loading="lazy"></p>
<p>那么带来的问题就来了：<br>
1.如果Prometheus重启怎么办？<br>
如果Prometheus重启的话，Prometheus本地会有缓存文件WAL存储还未落盘的数据，一般来说不会造成大量的数据丢失，但是在一定的数据量下，Prometheus重启会进行WAL文件加载到内存，加载过程会造成1-2个拉取间隔的数据丢失，出现断层。同时根据数据量大小不同，加载时间也会不一样<br>
2.如果查询更加久远的数据怎么办？<br>
Prometheus对于更加久远的数据查询方式是从filesystem-&gt;tsdb-&gt;Memory的方式,如果对于一些time series较多的指标来说，压力是比较大的，此时内存中(查询的time series+新拉取的time series),所有会发现根据查询数据量的不同内存会有不同程度的上升，很大的可能撑爆内存进行重启。<br>
3.如果落盘+内存不足怎么办<br>
如果对于新拉取数据来不及落盘就会进行重启、OOM等，那这个时候有必要扩大内存或者进行分离了</p>
<h1 id="针对内存问题进行分离">针对内存问题进行分离</h1>
<h2 id="架构策略">架构策略</h2>
<figure data-type="image" tabindex="1"><img src="https://github.com/amendge/amendge.github.io/post-images/1617867218714.png" alt="" loading="lazy"></figure>
<h2 id="逻辑">逻辑</h2>
<p>1.将所有要拉起的target等信息打好标签注册到consul<br>
2.Prometheus通过hashmod方式分块拉取consul配置<br>
3.每个单独Prometheus都会拉取不同于其他的配置<br>
4.最好对每个单独的Prometheus做数据汇总或者查询汇总</p>
<h2 id="步骤以k8s部署为例">步骤(以K8S部署为例)</h2>
<p>1.针对官方的镜像新增hashmod模块分配值<br>
Dockerfile:</p>
<pre><code>FROM  prometheus/prometheus:2.20.0
MAINTAINER name gecailong

COPY ./entrypoint.sh /bin

ENTRYPOINT [&quot;/bin/entrypoint.sh&quot;]
</code></pre>
<pre><code>entrypoint.sh：

#!/bin/sh

ID=${POD_NAME##*-}

cp /etc/prometheus/prometheus.yml /prometheus/prometheus-hash.yml

sed -i &quot;s/ID_NUM/$ID/g&quot; /prometheus/prometheus-hash.yml

/bin/prometheus --config.file=/prometheus/prometheus-hash.yml --query.max-concurrency=20 --storage.tsdb.path=/prometheus --storage.tsdb.max-block-duration=2h --storage.tsdb.min-block-duration=2h  --storage.tsdb.retention=2h --web.listen-address=:9090 --web.enable-lifecycle --web.enable-admin-api
</code></pre>
<p><strong>IDNUM： 为我们后面配置做准备</strong><br>
2.Prometheus部署<br>
Prometheus配置文件:</p>
<pre><code>  prometheus.yml: |
    global:
      scrape_interval:     15s
      evaluation_interval: 15s

      external_labels:
         monitor: 'k8s-sh-prod'
         service: 'k8s-all'
         ID: 'ID_NUM'
         ...
</code></pre>
<p>这个ID是为了我们在查询的时候可以区分同时也可以作为等下hashmod模块的对应值</p>
<p>以拉取Node信息为例:</p>
<pre><code>    - job_name: 'kubernetes-nodes'
      kubernetes_sd_configs:
      - role: node
      scheme: https
      tls_config:
        insecure_skip_verify: true
      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
      relabel_configs:
      - action: labelmap
        regex: __meta_kubernetes_node_label_(.+)
      - source_labels: [__meta_kubernetes_node_address_InternalIP]
        regex: (.+)
        target_label: __address__
        replacement: ${1}:10250 
      - source_labels: [__meta_kubernetes_node_name]
        regex: (.+)
        target_label: __metrics_path__
        replacement: /metrics
        #以下为hashmod配置部分
      - source_labels: [__meta_kubernetes_node_name]
        modulus:       10   #要分成的模块总数
        target_label:  __tmp_hash
        action:        hashmod
      - source_labels: [__tmp_hash]
        regex:         ID_NUM  #当前所属模块数
        action:        keep
</code></pre>
<p>部署文件:</p>
<pre><code>apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: prometheus
  name: prometheus-sts
  namespace: monitoring
spec:
  serviceName: &quot;prometheus&quot;
  replicas: 10   #hashmod总模块数
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
      - image: prometheus:2.20.0-hash
        name: prometheus
        securityContext:
           runAsUser: 0
        command:
        - &quot;/bin/entrypoint.sh&quot;  #hashmod脚本执行
        env:
        - name: POD_NAME   #根据statefulset的特性传入POD名称用于模块取值
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.name
        ports:
        - name: http
          containerPort: 9090
          protocol: TCP
</code></pre>
<p>针对数据存储和查询的问题可以通过Thanos进行查询聚合，也可以通过victoriametrics进行数据存储的聚合在grafana界面进行统一的查询</p>
<p>针对内存问题进行分离</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何用原生Prometheus监控大规模Kubernetes集群]]></title>
        <id>https://github.com/amendge/amendge.github.io/post/ru-he-yong-yuan-sheng-prometheus-jian-kong-da-gui-mo-kubernetes-ji-qun/</id>
        <link href="https://github.com/amendge/amendge.github.io/post/ru-he-yong-yuan-sheng-prometheus-jian-kong-da-gui-mo-kubernetes-ji-qun/">
        </link>
        <updated>2020-11-02T05:53:54.000Z</updated>
        <summary type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="/post-images/1617861678108.png" alt="" loading="lazy"></figure>
]]></summary>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://github.com/amendge/amendge.github.io/post-images/1617861678108.png" alt="" loading="lazy"></figure>
<!-- more -->
<p>概述<br>
对于Prometheus的组件能力是毋庸置疑的，但是使用久了会发现很多的性能问题，诸如内存问题、大规模拉取问题、大规模存储问题等等</p>
<p>如何基于云原生Prometheus进行K8S集群基础监控大规模数据拉取本文将会给出当前答案</p>
<h1 id="架构图">架构图</h1>
<p><img src="https://github.com/amendge/amendge.github.io/post-images/1617861700664.png" alt="" loading="lazy"><br>
我们当前的监控平台架构图，根据架构图可以看出我们当前的监控平台结合了多个成熟开源组件和能力完成了当前集群的数据+指标+展示的工作<br>
当前我们监控不同的K8S集群，包含不同功能、不同业务的集群，包含业务、基础和告警信息</p>
<h1 id="针对k8s集群监控">针对K8S集群监控</h1>
<p>我们采用常见的2种监控架构之一：<br>
1.Prometheus-operator<br>
2.Prometheus单独配置(选择的架构)<br>
tips:对于Prometheus-operator 确实易于部署化、简单的servicemonitor省了很大的力气,不过对于我们这样多种私有化集群来说维护成本稍微有点高,我们选择第二种方案更多的是想省略创建服务发现的步骤，更多的采用服务发现、服务注册的能力</p>
<h1 id="数据拉取">数据拉取</h1>
<p>在数据拉取方面我们做了一定的调整为了应对大规模节点或者数据对于apiserver的大压力问题和大规模数据拉取Prometheus内存oom问题<br>
a.利用K8s做服务发现，监控数据拉取由Prometheus之间拉取，降低apiserver拉取压力<br>
b.采用hashmod方式进行分布式拉取缓解内存压力<br>
RBAC权限修改;</p>
<pre><code>apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  name: prometheus
  namespace: monitoring
rules:
- apiGroups: [&quot;&quot;]
  resources:
  - nodes
  - nodes/proxy
  - nodes/metrics #新增路径为了外部拉取
  - nodes/metrics/cadvisor #新增路径为了外部拉取
  - services
  - endpoints
  - pods
  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
- apiGroups:
  - extensions
  resources:
  - ingresses
  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]
- nonResourceURLs: [&quot;/metrics&quot;]
  verbs: [&quot;get&quot;]
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus
  namespace: monitoring
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: prometheus
  namespace: monitoring
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: prometheus
subjects:
- kind: ServiceAccount
  name: prometheus
  namespace: monitoring

</code></pre>
<p><code>需要新增对于Node节点的/metrics和/metrics/cadvsior路径的拉取权限</code><br>
以完整配置拉取示例:</p>
<ul>
<li>对于thanos的数据写入提供写入阿里云OSS示例</li>
<li>对于node_exporter数据提取 线上除K8S外皆使用consul作为配置注册和发现</li>
<li>对于业务自定义基于K8S做服务发现和拉取</li>
</ul>
<h2 id="主机命名规则">主机命名规则</h2>
<p>机房-业务线-业务属性-序列数 (例:bja-athena-etcd-001)</p>
<h2 id="consul自动注册示例脚本">consul自动注册示例脚本</h2>
<pre><code>#!/bin/bash
  
#ip=$(ip addr show eth0|grep inet | awk '{ print $2; }' | sed 's/\/.*$//')
ip=$(ip addr | egrep -o '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}' | egrep &quot;^192\.168|^172\.21|^10\.101|^10\.100&quot; | egrep -v &quot;\.255$&quot; | awk -F. '{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4}' | head -n 1)
ahost=`echo $HOSTNAME`
idc=$(echo $ahost|awk -F &quot;-&quot; '{print $1}')
app=$(echo $ahost|awk -F &quot;-&quot; '{print $2}')
group=$(echo $ahost|awk -F &quot;-&quot; '{print $3}')

if [ &quot;$app&quot; != &quot;test&quot; ]
then
echo &quot;success&quot;
curl -X PUT -d &quot;{\&quot;ID\&quot;: \&quot;${ahost}_${ip}_node\&quot;, \&quot;Name\&quot;: \&quot;node_exporter\&quot;, \&quot;Address\&quot;: \&quot;${ip}\&quot;, \&quot;tags\&quot;: [\&quot;idc=${idc}\&quot;,\&quot;group=${group}\&quot;,\&quot;app=${app}\&quot;,\&quot;server=${ahost}\&quot;], \&quot;Port\&quot;: 9100,\&quot;checks\&quot;: [{\&quot;tcp\&quot;:\&quot;${ip}:9100\&quot;,\&quot;interval\&quot;: \&quot;60s\&quot;}]}&quot; http://consul_server:8500/v1/agent/service/register
fi

</code></pre>
<h2 id="完整配置文件示例">完整配置文件示例</h2>
<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
  namespace: monitoring
data:
  bucket.yaml: |
    type: S3
    config:
      bucket: &quot;gcl-download&quot;
      endpoint: &quot;gcl-download.oss-cn-beijing.aliyuncs.com&quot;
      access_key: &quot;xxxxxxxxxxxxxx&quot;
      insecure: false
      signature_version2: false
      secret_key: &quot;xxxxxxxxxxxxxxxxxx&quot;
      http_config:
        idle_conn_timeout: 0s

  prometheus.yml: |
    global:
      scrape_interval:     15s
      evaluation_interval: 15s

      external_labels:
         monitor: 'k8s-sh-prod'
         service: 'k8s-all'
         ID: 'ID_NUM'
         
    remote_write:
      - url: &quot;http://vmstorage:8400/insert/0/prometheus/&quot;
    remote_read:
      - url: &quot;http://vmstorage:8401/select/0/prometheus&quot;
         
    scrape_configs:
    - job_name: 'kubernetes-apiservers'
      kubernetes_sd_configs:
      - role: endpoints
      scheme: https
      tls_config:
        ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
      relabel_configs:
      - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]
        action: keep
        regex: default;kubernetes;https 
   
    - job_name: 'kubernetes-cadvisor'
      kubernetes_sd_configs:
      - role: node
      scheme: https
      tls_config:
        #ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        insecure_skip_verify: true
      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
      #bearer_token: monitoring
      relabel_configs:
      - action: labelmap
        regex: __meta_kubernetes_node_label_(.+)
      - source_labels: [__meta_kubernetes_node_address_InternalIP]
        regex: (.+)
        target_label: __address__
        replacement: ${1}:10250
      - source_labels: [__meta_kubernetes_node_name]
        regex: (.+)
        target_label: __metrics_path__
        replacement: /metrics/cadvisor
      - source_labels: [__meta_kubernetes_node_name]
        modulus:       10
        target_label:  __tmp_hash
        action:        hashmod
      - source_labels: [__tmp_hash]
        regex:         ID_NUM
        action:        keep
      metric_relabel_configs:
      - source_labels: [container]
        regex: (.+)
        target_label: container_name
        replacement: $1
        action: replace
      - source_labels: [pod]
        regex: (.+)
        target_label: pod_name
        replacement: $1
        action: replace
    
    - job_name: 'kubernetes-nodes'
      kubernetes_sd_configs:
      - role: node
      scheme: https
      tls_config:
        #ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        insecure_skip_verify: true
      bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token
      #bearer_token: monitoring
      relabel_configs:
      - action: labelmap
        regex: __meta_kubernetes_node_label_(.+)
      - source_labels: [__meta_kubernetes_node_address_InternalIP]
        regex: (.+)
        target_label: __address__
        replacement: ${1}:10250
      - source_labels: [__meta_kubernetes_node_name]
        regex: (.+)
        target_label: __metrics_path__
        replacement: /metrics
      - source_labels: [__meta_kubernetes_node_name]
        modulus:       10
        target_label:  __tmp_hash
        action:        hashmod
      - source_labels: [__tmp_hash]
        regex:         ID_NUM
        action:        keep
      metric_relabel_configs:
      - source_labels: [container]
        regex: (.+)
        target_label: container_name
        replacement: $1
        action: replace
      - source_labels: [pod]
        regex: (.+)
        target_label: pod_name
        replacement: $1
        action: replace

    - job_name: 'kubernetes-service-endpoints'
      kubernetes_sd_configs:
      - role: endpoints
        namespaces:
          names:
          - monitoring
      relabel_configs:
      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme]
        action: replace
        target_label: __scheme__
        regex: (https?)
      - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)
      - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port]
        action: replace
        target_label: __address__
        regex: ([^:]+)(?::\d+)?;(\d+)
        replacement: $1:$2
      - action: labelmap
        regex: __meta_kubernetes_service_label_(.+)
      - source_labels: [__meta_kubernetes_namespace]
        action: replace
        target_label: kubernetes_namespace
      - source_labels: [__meta_kubernetes_service_name]
        action: replace
        target_label: kubernetes_name

    - job_name: 'kubernetes-pods'
      kubernetes_sd_configs:
      - role: pod
        namespaces:
          names:
          - default
      relabel_configs:
      - action: labelmap
        regex: __meta_kubernetes_pod_label_(.+)
      - source_labels: [__meta_kubernetes_namespace]
        action: replace
        target_label: kubernetes_namespace
      - source_labels: [__meta_kubernetes_pod_name]
        action: replace
        target_label: kubernetes_pod_name

    - job_name: 'ingress-nginx-endpoints'
      kubernetes_sd_configs:
      - role: pod
        namespaces:
          names:
          - nginx-ingress
      relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scheme]
        action: replace
        target_label: __scheme__
        regex: (https?)
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
        action: replace
        target_label: __metrics_path__
        regex: (.+)
      - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
        action: replace
        target_label: __address__
        regex: ([^:]+)(?::\d+)?;(\d+)
        replacement: $1:$2

    - job_name: 'node_exporter'
      consul_sd_configs:
      - server: 'consul_server:8500'
      relabel_configs:
          - source_labels: [__address__]
          modulus:       10
          target_label:  __tmp_hash
          action:        hashmod
          - source_labels: [__tmp_hash]
          regex:         ID_NUM
          action:        keep
          - source_labels: [__tmp_hash]
          regex:       '(.*)'
          replacement: '${1}'
          target_label: hash_num
          - source_labels: [__meta_consul_tags]
          regex: .*test.*
          action: drop
          - source_labels: [__meta_consul_tags]
          regex: ',(?:[^,]+,){0}([^=]+)=([^,]+),.*'
          replacement: '${2}'
          target_label: '${1}'
          - source_labels: [__meta_consul_tags]
          regex: ',(?:[^,]+,){1}([^=]+)=([^,]+),.*'
          replacement: '${2}'
          target_label: '${1}'
          - source_labels: [__meta_consul_tags]
          regex: ',(?:[^,]+,){2}([^=]+)=([^,]+),.*'
          replacement: '${2}'
          target_label: '${1}'
          - source_labels: [__meta_consul_tags]
          regex: ',(?:[^,]+,){3}([^=]+)=([^,]+),.*'
          replacement: '${2}'
          target_label: '${1}'
          - source_labels: [__meta_consul_tags]
          regex: ',(?:[^,]+,){4}([^=]+)=([^,]+),.*'
          replacement: '${2}'
          target_label: '${1}'
          - source_labels: [__meta_consul_tags]
          regex: ',(?:[^,]+,){5}([^=]+)=([^,]+),.*'
          replacement: '${2}'
          target_label: '${1}'
          - source_labels: [__meta_consul_tags]
          regex: ',(?:[^,]+,){6}([^=]+)=([^,]+),.*'
          replacement: '${2}'
          target_label: '${1}'
          - source_labels: [__meta_consul_tags]
          regex: ',(?:[^,]+,){7}([^=]+)=([^,]+),.*'
          replacement: '${2}'
          target_label: '${1}'

    - job_name: '自定义业务监控'
      proxy_url: http://127.0.0.1:8888   #根据业务属性
      scrape_interval: 5s
      metrics_path: '/'  #根据业务提供路径
      params:   ##根据业务属性是否带有
        method: ['get']  
      kubernetes_sd_configs:
      - role: pod
      relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
      - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
        action: replace
        target_label: __address__
        regex: ([^:]+)(?::\d+)?;(\d+)
        replacement: $1:$2
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_name_label]
        action: keep
        regex: monitor  #业务自定义label
      - action: labelmap
        regex: __meta_kubernetes_pod_label_(.+)
      - source_labels: [__meta_kubernetes_pod_name]
        action: keep
        regex: (.*)
      - source_labels: [__meta_kubernetes_namespace]
        action: replace
        target_label: kubernetes_namespace
</code></pre>
<h2 id="自定义业务拉取标识可集成cicd">自定义业务拉取标识(可集成CICD)</h2>
<pre><code>  template:
    metadata:
      annotations:
        prometheus.io/port: &quot;port&quot; #业务端口
        prometheus.io/scrape: &quot;true&quot;
        prometheus.name/label: monitor  #自定义标签
</code></pre>
<h2 id="hashmod配置方式">hashmod配置方式：</h2>
<h3 id="1针对官方的镜像新增hashmod模块分配值">1.针对官方的镜像新增hashmod模块分配值</h3>
<p>Dockerfile:</p>
<pre><code>FROM  prometheus/prometheus:2.20.0
MAINTAINER name gecailong

COPY ./entrypoint.sh /bin

ENTRYPOINT [&quot;/bin/entrypoint.sh&quot;]
</code></pre>
<p>entrypoint.sh：</p>
<pre><code>#!/bin/sh

ID=${POD_NAME##*-}

cp /etc/prometheus/prometheus.yml /prometheus/prometheus-hash.yml

sed -i &quot;s/ID_NUM/$ID/g&quot; /prometheus/prometheus-hash.yml

/bin/prometheus --config.file=/prometheus/prometheus-hash.yml --query.max-concurrency=20 --storage.tsdb.path=/prometheus --storage.tsdb.max-block-duration=2h --storage.tsdb.min-block-duration=2h  --storage.tsdb.retention=2h --web.listen-address=:9090 --web.enable-lifecycle --web.enable-admin-api
</code></pre>
<p><strong>IDNUM： 为我们后面配置做准备_</strong></p>
<h3 id="2prometheus部署">2.Prometheus部署</h3>
<p>Prometheus配置文件:</p>
<pre><code>  prometheus.yml: |
      external_labels:
         monitor: 'k8s-sh-prod'
         service: 'k8s-all'
         ID: 'ID_NUM'
         ...
</code></pre>
<p>这个ID是为了我们在查询的时候可以区分同时也可以作为等下hashmod模块的对应值<br>
部署文件:</p>
<pre><code>---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: prometheus
  name: prometheus-sts
  namespace: monitoring
spec:
  serviceName: &quot;prometheus&quot;
  replicas: 10 #hashmod总模块数
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
      - image: gecailong/prometheus-hash:0.0.1
        name: prometheus
        securityContext:
           runAsUser: 0
        command:
        - &quot;/bin/entrypoint.sh&quot;
        env:
        - name: POD_NAME  #根据statefulset的特性传入POD名称用于模块取值
          valueFrom:
            fieldRef:
              apiVersion: v1
              fieldPath: metadata.name
        ports:
        - name: http
          containerPort: 9090
          protocol: TCP
        volumeMounts:
        - mountPath: &quot;/etc/prometheus&quot;
          name: config-volume
        - mountPath: &quot;/prometheus&quot;
          name: data
        resources:
          requests:
            cpu: 500m
            memory: 1000Mi
          limits:
            memory: 2000Mi
      - image: gecailong/prometheus-thanos:v0.17.1
        name: sidecar
        imagePullPolicy: IfNotPresent
        args:
        - &quot;sidecar&quot;
        - &quot;--grpc-address=0.0.0.0:10901&quot;
        - &quot;--grpc-grace-period=1s&quot;
        - &quot;--http-address=0.0.0.0:10902&quot;
        - &quot;--http-grace-period=1s&quot;
        - &quot;--prometheus.url=http://127.0.0.1:9090&quot;
        - &quot;--tsdb.path=/prometheus&quot;
        - &quot;--log.level=info&quot;
        - &quot;--objstore.config-file=/etc/prometheus/bucket.yaml&quot;
        ports:
        - name: http-sidecar
          containerPort: 10902
        - name: grpc-sidecar
          containerPort: 10901
        volumeMounts:
        - mountPath: &quot;/etc/prometheus&quot;
          name: config-volume
        - mountPath: &quot;/prometheus&quot;
          name: data
      serviceAccountName: prometheus
      hostNetwork: true
      dnsPolicy: ClusterFirstWithHostNet
      imagePullSecrets: 
        - name: regsecret
      volumes:
      - name: config-volume
        configMap:
          name: prometheus-config
      - name: data
        hostPath:
          path: /data/prometheus
</code></pre>
<h1 id="数据聚合">数据聚合</h1>
<p>Thanos我们从18年一开始就用的它，虽然一开始的版本有很多bug也给我们带来了很多困扰,同时我们也提了很多的issue，慢慢的稳定之后，我们在此之前线上都是使用v0.2.1版本进行线上长期使用,最新的版本已经去除了基于grpc cluster服务发现的功能，UI也更加的丰富。😀我们也进行了监控平台架构重构<br>
我们数据聚合采用Thanos进行查询数据聚合，同时后面我们提到的数据存储组件victoriametrics也可以实现数据聚合的功能，针对Thanos，我们主要使用它的几个子组件：query、sidecar、rule，至于其他的组件如compact、store、bucket等依据自己的业务没有进行使用.<br>
我们的Thanos+Prometheus的架构图已在开头展示，以下仅给出部署和注意事项:<br>
Thanos组件部署:<br>
sidecar:(我们采用和Prometheus放在同一POD)</p>
<pre><code>      - image: gecailong/prometheus-thanos:v0.17.1
        name: thanos
        imagePullPolicy: IfNotPresent
        args:
        - &quot;sidecar&quot;
        - &quot;--grpc-address=0.0.0.0:10901&quot;
        - &quot;--grpc-grace-period=1s&quot;
        - &quot;--http-address=0.0.0.0:10902&quot;
        - &quot;--http-grace-period=1s&quot;
        - &quot;--prometheus.url=http://127.0.0.1:9090&quot;
        - &quot;--tsdb.path=/prometheus&quot;
        - &quot;--log.level=info&quot;
        - &quot;--objstore.config-file=/etc/prometheus/bucket.yaml&quot;
        ports:
        - name: http-sidecar
          containerPort: 10902
        - name: grpc-sidecar
          containerPort: 10901
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        volumeMounts:
        - mountPath: &quot;/etc/prometheus&quot;
          name: config-volume
        - mountPath: &quot;/prometheus&quot;
          name: data
</code></pre>
<p>query组件部署:</p>
<pre><code>---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: query
  name: thanos-query
  namespace: monitoring
spec:
  replicas: 3
  selector:
    matchLabels:
      app: query
  template:
    metadata:
      labels:
        app: query
    spec:
      containers:
      - image: gecailong/prometheus-thanos:v0.17.1
        name: query
        imagePullPolicy: IfNotPresent
        args:
        - &quot;query&quot;
        - &quot;--http-address=0.0.0.0:19090&quot;
        - &quot;--grpc-address=0.0.0.0:10903&quot;
        - &quot;--store=dnssrv+_grpc._tcp.prometheus-sidecar-svc.monitoring.svc.cluster.local&quot;
        - &quot;--store=dnssrv+_grpc._tcp.sidecar-query.monitoring.svc.cluster.local&quot;
        - &quot;--store=dnssrv+_grpc._tcp.sidecar-rule.monitoring.svc.cluster.local&quot;
        ports:
        - name: http-query
          containerPort: 19090
        - name: grpc-query
          containerPort: 10903
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
      hostNetwork: true
      dnsPolicy: ClusterFirstWithHostNet
</code></pre>
<p>rule组件部署:</p>
<pre><code>---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app: query
  name: thanos-rule
  namespace: monitoring
spec:
  replicas: 2
  serviceName: &quot;sidecar-rule&quot;
  selector:
    matchLabels:
      app: rule
  template:
    metadata:
      labels:
        app: rule
    spec:
      containers:
      - image: gecailong/prometheus-thanos:v0.17.1
        name: rule
        imagePullPolicy: IfNotPresent
        args:
        - &quot;rule&quot;
        - &quot;--http-address=0.0.0.0:10902&quot;
        - &quot;--grpc-address=0.0.0.0:10901&quot;
        - &quot;--data-dir=/data&quot;
        - &quot;--rule-file=/prometheus-rules/*.yaml&quot;
        - &quot;--alert.query-url=http://sidecar-query:19090&quot;
        - &quot;--alertmanagers.url=http://alertmanager:9093&quot;
        - &quot;--query=http://sidecar-query:19090&quot;
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        volumeMounts:
        - mountPath: &quot;/prometheus-rules&quot;
          name: config-volume
        - mountPath: &quot;/data&quot;
          name: data
        resources:
          requests:
            cpu: 100m
            memory: 100Mi
          limits:
            memory: 1500Mi
      hostNetwork: true
      dnsPolicy: ClusterFirstWithHostNet
      volumes:
      - name: config-volume
        configMap:
          name: prometheus-rule
      - name: data
        hostPath:
          path: /data/prometheus
</code></pre>
<p>rule通用告警规则和配置:</p>
<pre><code>apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-rule
  namespace: monitoring
data:
  k8s_cluster_rule.yaml: |+
    groups:
    - name: pod_etcd_monitor
      rules:
      - alert: pod_etcd_num_is_changing
        expr: sum(kube_pod_info{pod=~&quot;etcd.*&quot;})by(monitor) &lt; 3
        for: 1m
        labels:
          level: high
          service: etcd
        annotations:
          summary: &quot;集群:{{ $labels.monitor }},etcd集群pod低于正常总数&quot;
          description: &quot;总数为3,当前值是{{ $value}}&quot;
    - name: pod_scheduler_monitor
      rules:
      - alert: pod_scheduler_num_is_changing
        expr: sum(kube_pod_info{pod=~&quot;kube-scheduler.*&quot;})by(monitor) &lt; 3
        for: 1m
        labels:
          level: high
          service: scheduler
        annotations:
          summary: &quot;集群:{{ $labels.monitor }},scheduler集群pod低于正常总数&quot;
          description: &quot;总数为3,当前值是{{ $value}}&quot;
    - name: pod_controller_monitor
      rules:
      - alert: pod_controller_num_is_changing
        expr: sum(kube_pod_info{pod=~&quot;kube-controller-manager.*&quot;})by(monitor) &lt; 3
        for: 1m
        labels:
          level: high
          service: controller
        annotations:
          summary: &quot;集群:{{ $labels.monitor }},controller集群pod低于正常总数&quot;
          description: &quot;总数为3,当前值是{{ $value}}&quot;
    - name: pod_apiserver_monitor
      rules:
      - alert: pod_apiserver_num_is_changing
        expr: sum(kube_pod_info{pod=~&quot;kube-apiserver.*&quot;})by(monitor) &lt; 3
        for: 1m
        labels:
          level: high
          service: controller
        annotations:
          summary: &quot;集群:{{ $labels.monitor }},apiserver集群pod低于正常总数&quot;
          description: &quot;总数为3,当前值是{{ $value}}&quot;

  k8s_master_resource_rules.yaml: |+
    groups:
    - name: node_cpu_resource_monitor
      rules:
      - alert: 节点CPU使用量
        expr:  sum(kube_pod_container_resource_requests_cpu_cores{node=~&quot;.*&quot;})by(node)/sum(kube_node_status_capacity_cpu_cores{node=~&quot;.*&quot;})by(node)&gt;0.7
        for: 1m
        labels:
          level: disaster
          service: node
        annotations:
          summary: &quot;集群NODE节点总的CPU使用核数已经超过了70%&quot;
          description: &quot;集群:{{ $labels.monitor }},节点:{{ $labels.node }}当前值为{{ $value }}!&quot;
    - name: node_memory_resource_monitor
      rules:
      - alert: 节点内存使用量
        expr:  sum(kube_pod_container_resource_limits_memory_bytes{node=~&quot;.*&quot;})by(node)/sum(kube_node_status_capacity_memory_bytes{node=~&quot;.*&quot;})by(node)&gt;0.7
        for: 1m
        labels:
          level: disaster
          service: node
        annotations:
          summary: &quot;集群NODE节点总的memory使用核数已经超过了70%&quot;
          description: &quot;集群:{{ $labels.monitor }},节点:{{ $labels.node }}当前值为{{ $value }}!&quot;
    - name: 节点POD使用率
      rules:
      - alert: 节点pod使用率
        expr: sum by(node,monitor) (kube_pod_info{node=~&quot;.*&quot;}) / sum by(node,monitor) (kube_node_status_capacity_pods{node=~&quot;.*&quot;})&gt; 0.9
        for: 1m
        labels:
          level: disaster
          service: node
        annotations:
          summary: &quot;集群NODE节点总的POD使用数量已经超过了90%&quot;
          description: &quot;集群:{{ $labels.monitor }},节点:{{ $labels.node }}当前值为{{ $value }}!&quot;      
    - name: master_cpu_used
      rules:
      - alert: 主节点CPU使用率
        expr:  sum(kube_pod_container_resource_limits_cpu_cores{node=~'master.*'})by(node)/sum(kube_node_status_capacity_cpu_cores{node=~'master.*'})by(node)&gt;0.7
        for: 1m
        labels:
          level: disaster
          service: node
        annotations:
          summary: &quot;集群Master节点总的CPU申请核数已经超过了0.7,当前值为{{ $value }}!&quot;
          description: &quot;集群:{{ $labels.monitor }},节点:{{ $labels.node }}当前值为{{ $value }}!&quot; 
    - name: master_memory_resource_monitor
      rules:
      - alert: 主节点内存使用率
        expr:  sum(kube_pod_container_resource_limits_memory_bytes{node=~'master.*'})by(node)/sum(kube_node_status_capacity_memory_bytes{node=~'master.*'})by(node)&gt;0.7
        for: 1m
        labels:
          level: disaster
          service: node
        annotations:
          summary: &quot;集群Master节点总的内存使用量已经超过了70%&quot;
          description: &quot;集群:{{ $labels.monitor }},节点:{{ $labels.node }}当前值为{{ $value }}!&quot;
    - name: master_pod_resource_monitor
      rules:
      - alert: 主节点POD使用率
        expr: sum(kube_pod_info{node=~&quot;master.*&quot;}) by (node) / sum(kube_node_status_capacity_pods{node=~&quot;master.*&quot;}) by (node)&gt;0.7
        for: 1m
        labels:
          level: disaster
          service: node
        annotations:
          summary: &quot;集群Master节点总的POD使用数量已经超过了70%&quot;
          description: &quot;集群:{{ $labels.monitor }},节点:{{ $labels.node }}当前值为{{ $value }}!&quot;     
  k8s_node_rule.yaml: |+
    groups:
    - name: K8sNodeMonitor
      rules:
      - alert: 集群节点资源监控
        expr: kube_node_status_condition{condition=~&quot;OutOfDisk|MemoryPressure|DiskPressure&quot;,status!=&quot;false&quot;} ==1
        for: 1m
        labels:
          level: disaster
          service: node
        annotations:
          summary: &quot;集群节点内存或磁盘资源短缺&quot;
          description: &quot;节点:{{ $labels.node }},集群:{{ $labels.monitor }},原因:{{ $labels.condition }}&quot;
      - alert: 集群节点状态监控
        expr: sum(kube_node_status_condition{condition=&quot;Ready&quot;,status!=&quot;true&quot;})by(node)  == 1
        for: 2m
        labels:
          level: disaster
          service: node
        annotations:
          summary: &quot;集群节点状态出现错误&quot;
          description: &quot;节点:{{ $labels.node }},集群:{{ $labels.monitor }}&quot;
      - alert: 集群POD状态监控
        expr: sum (kube_pod_container_status_terminated_reason{reason!~&quot;Completed|Error&quot;})  by (pod,reason) ==1
        for: 1m
        labels:
          level: high
          service: pod
        annotations:
          summary: &quot;集群pod状态出现错误&quot;
          description: &quot;集群:{{ $labels.monitor }},名称:{{ $labels.pod }},原因:{{ $labels.reason}}&quot;
      - alert: 集群节点CPU使用监控
        expr:  sum(node_load1) BY (instance) / sum(rate(node_cpu_seconds_total[1m])) BY (instance) &gt; 2
        for: 5m
        labels:
          level: disaster
          service: node
        annotations:
          summary: &quot;机器出现cpu平均负载过高&quot;
          description: &quot;节点: {{ $labels.instance }}平均每核大于2&quot;
      - alert: NodeMemoryOver80Percent
        expr:  (1 - avg by (instance)(node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes))* 100 &gt;85
        for: 1m
        labels:
          level: disaster
          service: node
        annotations:
          summary: &quot;机器出现内存使用超过85%&quot;
          description: &quot;节点: {{ $labels.instance }}&quot;
  k8s_pod_rule.yaml: |+
    groups:
      - name: pod_status_monitor
        rules:
        - alert: pod错误状态监控
          expr: changes(kube_pod_status_phase{phase=~&quot;Failed&quot;}[5m]) &gt;0
          for: 1m
          labels:
            level: high
            service: pod-failed
          annotations:
            summary: &quot;集群:{{ $labels.monitor }}存在pod状态异常&quot;
            description: &quot;pod:{{$labels.pod}},状态:{{$labels.phase}}&quot;
        - alert: pod异常状态监控
          expr: sum(kube_pod_status_phase{phase=&quot;Pending&quot;})by(namespace,pod,phase)&gt;0
          for: 3m
          labels:
            level: high
            service: pod-pending
          annotations:
            summary: &quot;集群:{{ $labels.monitor }}存在pod状态pening异常超10分钟&quot;
            description: &quot;pod:{{$labels.pod}},状态:{{$labels.phase}}&quot;
        - alert: pod等待状态监控
          expr: sum(kube_pod_container_status_waiting_reason{reason!=&quot;ContainerCreating&quot;})by(namespace,pod,reason)&gt;0
          for: 1m
          labels:
            level: high
            service: pod-wait
          annotations:
            summary: &quot;集群:{{ $labels.monitor }}存在pod状态Wait异常超5分钟&quot;
            description: &quot;pod:{{$labels.pod}},状态:{{$labels.reason}}&quot;
        - alert: pod非正常状态监控
          expr: sum(kube_pod_container_status_terminated_reason)by(namespace,pod,reason)&gt;0
          for: 1m
          labels:
            level: high
            service: pod-nocom
          annotations:
            summary: &quot;集群:{{ $labels.monitor }}存在pod状态Terminated异常超5分钟&quot;
            description: &quot;pod:{{$labels.pod}},状态:{{$labels.reason}}&quot;
        - alert: pod重启监控
          expr: changes(kube_pod_container_status_restarts_total[20m])&gt;3
          for: 3m
          labels:
            level: high
            service: pod-restart
          annotations:
            summary: &quot;集群:{{ $labels.monitor }}存在pod半小时之内重启次数超过3次!&quot;
            description: &quot;pod:{{$labels.pod}}&quot;
      - name: deployment_replicas_monitor
        rules:
        - alert: deployment监控
          expr: sum(kube_deployment_status_replicas_unavailable)by(namespace,deployment) &gt;2
          for: 3m
          labels:
            level: high
            service: deployment-replicas
          annotations:
            summary: &quot;集群:{{ $labels.monitor }},deployment:{{$labels.deployment}} 副本数未达到期望值! &quot;
            description: &quot;空间:{{$labels.namespace}}，当前不可用副本:{{$value}},请检查&quot;
      - name: daemonset_replicas_monitor
        rules:
        - alert: Daemonset监控
          expr: sum(kube_daemonset_status_desired_number_scheduled - kube_daemonset_status_current_number_scheduled)by(daemonset,namespace) &gt;2
          for: 3m
          labels:
            level: high
            service: daemonset
          annotations:
            summary: &quot;集群:{{ $labels.monitor }},daemonset:{{$labels.daemonset}} 守护进程数未达到期望值!&quot;
            description: &quot;空间:{{$labels.namespace}},当前不可用副本:{{$value}},请检查&quot;
      - name: satefulset_replicas_monitor
        rules:
        - alert: Satefulset监控
          expr: (kube_statefulset_replicas - kube_statefulset_status_replicas_ready) &gt;2
          for: 3m
          labels:
            level: high
            service: statefulset
          annotations:
            summary: &quot;集群:{{ $labels.monitor }},statefulset:{{$labels.statefulset}} 副本数未达到期望值!&quot;
            description: &quot;空间:{{$labels.namespace}}，当前不可用副本:{{$value}},请检查&quot;
      - name: pvc_replicas_monitor
        rules:
        - alert: PVC监控
          expr: kube_persistentvolumeclaim_status_phase{phase!=&quot;Bound&quot;} == 1
          for: 5m
          labels:
            level: high
            service: pvc
          annotations:
            summary: &quot;集群:{{ $labels.monitor }},statefulset:{{$labels.persistentvolumeclaim}} 异常未bound成功!&quot;
            description: &quot;pvc出现异常&quot;
      - name: K8sClusterJob
        rules:	  
        - alert: 集群JOB状态监控
          expr: sum(kube_job_status_failed{job=&quot;kubernetes-service-endpoints&quot;,k8s_app=&quot;kube-state-metrics&quot;})by(job_name) ==1
          for: 1m
          labels:
            level: disaster
            service: job
          annotations:
            summary: &quot;集群存在执行失败的Job&quot;
            description: &quot;集群:{{ $labels.monitor }},名称:{{ $labels.job_name }}&quot;
      - name: pod_container_cpu_resource_monitor
        rules:
        - alert: 容器内cpu占用监控
          expr: namespace:container_cpu_usage_seconds_total:sum_rate / sum(kube_pod_container_resource_limits_cpu_cores) by (monitor,namespace,pod_name)&gt; 0.8
          for: 1m
          labels:
            level: high
            service: container_cpu
          annotations:
            summary: &quot;集群:{{ $labels.monitor }} 出现Pod CPU使用率已经超过申请量的80%,&quot;
            description: &quot;namespace:{{$labels.namespace}}的pod:{{$labels.pod}},当前值为{{ $value }}&quot;
        - alert: 容器内mem占用监控
          expr: namespace:container_memory_usage_bytes:sum/ sum(kube_pod_container_resource_limits_memory_bytes)by(monitor,namespace,pod_name) &gt; 0.8
          for: 2m
          labels:
            level: high
            service: container_mem
          annotations:
            summary: &quot;集群:{{ $labels.monitor }} 出现Pod memory使用率已经超过申请量的90%&quot;
            description: &quot;namespace:{{$labels.namespace}}的pod:{{$labels.pod}},当前值为{{ $value }}&quot;
        
  redis_rules.yaml: |+
    groups:
    - name: k8s_container_rule
    rules:
    - expr: sum(rate(container_cpu_usage_seconds_total[5m])) by (monitor,namespace,pod_name)
        record: namespace:container_cpu_usage_seconds_total:sum_rate
    - expr: sum(container_memory_usage_bytes{container_name=&quot;POD&quot;}) by (monitor,namespace,pod_name)
        record: namespace:container_memory_usage_bytes:sum
</code></pre>
<p><code>注意: 因为组件都在同一集群我们采用dnssrv的方式进行发现其他组件节点，其实对于容器内部的dnssrv方便很多，我们只需要创建一个所需要的headless service 并且使用dns srv的话，需要设置 clusterIP: None 即可.</code><br>
thanos-query-svc:</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  labels:
    app: query
  name: sidecar-query
spec:
  ports:
  - name: web
    port: 19090
    protocol: TCP
    targetPort: 19090
  selector:
    app: query
</code></pre>
<p>thanos-rule-svc:</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  labels:
    app: rule
  name: sidecar-rule
spec:
  clusterIP: None
  ports:
  - name: web
    port: 10902
    protocol: TCP
    targetPort: 10902
  - name: grpc
    port: 10901
    protocol: TCP
    targetPort: 10901
  selector:
    app: rule
</code></pre>
<p>prometheus+sidecar:</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  labels:
    app: prometheus
  name: prometheus-sidecar-svc
spec:
  clusterIP: None
  ports:
  - name: web
    port: 9090
    protocol: TCP
    targetPort: 9090
  - name: grpc
    port: 10901
    protocol: TCP
    targetPort: 10901
  selector:
    app: prometheus
</code></pre>
<p>效果图:<br>
pod指标监控多集群示例:<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617861801737.png" alt="" loading="lazy"><br>
监控告警规则示例:<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617861838781.png" alt="" loading="lazy"><br>
Thanos首页:<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617861846507.png" alt="" loading="lazy"></p>
<h1 id="数据存储">数据存储</h1>
<p>对于Prometheus的数据存储我们也走了很多的弯路..</p>
<ul>
<li>对于开始我们使用过influxdb最终因为集群版问题放弃了，也试过重写Prometheus-adapter接入opentsdb,后来因为部分通配符维护难问题也放弃了(其实还是tcollecter的搜集问题放弃的)，我们也尝试过用Thanos-store S3打入ceph因为副本问题成本太高，也打入过阿里云的OSS,存的多 但是取数据成了一个问题。后面我们迎来了victoriametrics，基本上能解决我们大部分的主要问题。<br>
架构:<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617861859014.png" alt="" loading="lazy"></li>
</ul>
<p>victoriametrics 本身是一个时序数据库，对于这样一个远端存储，同时也可以单独作为Prometheus数据源查询使用。<br>
优势:<br>
1.具有较高的压缩比和高性能<br>
2.可以提供和Prometheus同等的数据源展示<br>
3.支持metricsql同时查询时进行相同meitrics数据聚合<br>
4.开源的集群版本(简直无敌)<br>
对于victoriametrics我们做过一个简单的测试，相同的数据在和Prometheus原有数据对比中<br>
内存大概减少50%，CPU节省超40%，磁盘占用减少约40%.并且我们通过这种方式分离了写入和读取的通道避免了新老数据共存内存造成的大内存和OOM问题，也同时提供了一个长期数据存储的成本方案<br>
victoriametrics部署:<br>
vminsert部署:</p>
<pre><code>apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: monitor-vminsert
spec:
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      vminsert: online
  template:
    metadata:
      labels:
        vminsert: online
    spec:
      containers:
      - args:
        - -storageNode=vmstorage:8400
        image: victoriametrics/vminsert:v1.39.4-cluster
        imagePullPolicy: IfNotPresent
        name: vminsert
        ports:
        - containerPort: 8480
          name: vminsert
          protocol: TCP
      dnsPolicy: ClusterFirst
      hostNetwork: true
      nodeSelector:
        vminsert: online
      restartPolicy: Always
  updateStrategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
</code></pre>
<p>vmselect部署:</p>
<pre><code>apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: monitor-vmselect
spec:
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      vmselect: online
  template:
    metadata:
      labels:
        vmselect: online
    spec:
      containers:
      - args:
        - -storageNode=vmstorage:8400
        image: victoriametrics/vmselect:v1.39.4-cluster
        imagePullPolicy: IfNotPresent
        name: vmselect
        ports:
        - containerPort: 8481
          name: vmselect
          protocol: TCP
      dnsPolicy: ClusterFirst
      hostNetwork: true
      nodeSelector:
        vmselect: online
      restartPolicy: Always
  updateStrategy:
    rollingUpdate:
      maxUnavailable: 1
    type: RollingUpdate
</code></pre>
<p>vmstorage部署:</p>
<pre><code>apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: monitor-vmstorage
spec:
  replicas: 10
  serviceName: vmstorage
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      vmstorage: online
  template:
    metadata:
      labels:
        vmstorage: online
    spec:
      containers:
      - args:
        - --retentionPeriod=1
        - --storageDataPath=/storage
        image: victoriametrics/vmstorage:v1.39.4-cluster
        imagePullPolicy: IfNotPresent
        name: vmstorage
        ports:
        - containerPort: 8482
          name: http
          protocol: TCP
        - containerPort: 8400
          name: vminsert
          protocol: TCP
        - containerPort: 8401
          name: vmselect
          protocol: TCP
        volumeMounts:
        - mountPath: /data
          name: data
      hostNetwork: true
      nodeSelector:
        vmstorage: online
      restartPolicy: Always
      volumes:
      - hostPath:
          path: /data/vmstorage
          type: &quot;&quot;
        name: data
</code></pre>
<p>vmstorage-svc (提供接口供查询、写入):</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  labels:
    vmstorage: staging
  name: vmstorage
spec:
  ports:
  - name: http
    port: 8482
    protocol: TCP
    targetPort: http
  - name: vmselect
    port: 8401
    protocol: TCP
    targetPort: vmselect
  - name: vminsert
    port: 8400
    protocol: TCP
    targetPort: vminsert
  selector:
    vmstorage: staging
  type: NodePort

</code></pre>
<p>vminsert-svc</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  labels:
    vminsert: online
  name: monitor-vminsert
spec:
  ports:
  - name: vminsert
    port: 8480
    protocol: TCP
    targetPort: vminsert
  selector:
    vminsert: online
  type: NodePort
</code></pre>
<p>vmselet-svc</p>
<pre><code>apiVersion: v1
kind: Service
metadata:
  labels:
    vmselect: online
  name: monitor-vmselect
spec:
  ports:
  - name: vmselect
    port: 8481
    protocol: TCP
    targetPort: vmselect
  selector:
    vmselect: online
  type: NodePort
</code></pre>
<p>进行部署完成后需要修改Prometheus配置进行写入和查询支持</p>
<pre><code>    remote_write:
      - url: &quot;http://vmstorage:8400/insert/0/prometheus/&quot;
    remote_read:
      - url: &quot;http://vmstorage:8401/select/0/prometheus&quot;
</code></pre>
<p>grafana数据源配置:</p>
<pre><code>选择数据源类型: Prometheus
http://vmstorage:8401/select/0/prometheus
</code></pre>
<p>效果图:<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617861894002.png" alt="" loading="lazy"></p>
<h1 id="告警信息">告警信息</h1>
<p><code>告警规则都是由thanos rule推送至alertmanager</code><br>
告警采用的时alertmanager进行告警,同时搭配自己的告警平台进行告警的分发.<br>
在配置中我们按照alertname和monitor进行分组,可以实现相同alert name下的所有告警分成一个组，进行基于Prometheus的聚合告警，同时因为现网POD较多，如发生大规模POD异常进行聚合时数据较大，单独分类。效果如后面展示<br>
告警静默配置:因为现网告警都在label中定义了告警级别(warning、high、disaster)级别,对于最低级别的告警我们默认不走告警平台，根据告警的等级和告警规则进行静默。<br>
例:<br>
1.同monitor集群下某一个alertname按照instance进行静默，<br>
2.对于大量POD告警我们基于POD告警类型进行静默<br>
第一次告警时会根据分组聚合信息进行所有告警信息推送<br>
alertmanager配置:</p>
<pre><code>global:
  smtp_smarthost: 'mail.xxxxxxx.com:25'
  smtp_from: 'xxxxxxx@xxxxxxx.com'
  smtp_auth_username: 'xxxxxxx@xxxxxxx.com'
  smtp_auth_password: 'xxxxxxx'
  smtp_require_tls: false

route:
  group_by: ['alertname','pod','monitor']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 6h
  receiver: 'webhook'

  routes:
  - receiver: 'mail'
    match:
      level: warning

receivers:
- name: 'mail'
  email_configs:
  - to: 'amend@xxxxx.com,amend2@xxxxx.com'
    send_resolved: true

- name: 'webhook'
  webhook_configs:
  - url: 'http://alert.xxx.com/alert/prometheus'
    send_resolved: true
inhibit_rules:
  - source_match:
      level: 'disaster'
    target_match_re:
      level: 'high|disaster'
    equal: ['alertname','instance','monitor']
  - source_match:
      level: 'high'
    target_match_re:
      level: 'high'
    equal: ['alertname','instance','monitor']

</code></pre>
<p>告警聚合代码示例(python):</p>
<pre><code>        try:
            payload = eval(self.request.body)
        except json.decoder.JSONDecodeError:
            raise web.HTTPError(400)
        alert_row = payload['alerts']
        try:
            if len(alert_row) &lt;2:
               description =  alert_row[0]['annotations']['description']
               summary =  alert_row[0]['annotations']['summary']
            else:
               for alert in alert_row:
                   description +=  alert['annotations']['description'] + '\n'
               summary = '[聚合告警] '+ alert_row[0]['annotations']['summary']
        except:
            pass
        try:
            namespace =  alert_row[0]['labels']['namespace']
        except:
            pass

</code></pre>
<p>效果:<br>
1.对于POD的监控<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617861923719.png" alt="" loading="lazy"><br>
2.对于instance级别告警<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617861946897.png" alt="" loading="lazy"><br>
3.对于业务级别告警<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617861956813.png" alt="" loading="lazy"><br>
源码和模板:<br>
https://github.com/gecailong/K8sMonitor</p>
<p>参考:<br>
https://github.com/thanos-io/thanos<br>
https://github.com/VictoriaMetrics/VictoriaMetrics<br>
https://github.com/gecailong/K8sMonitor<br>
https://blog.csdn.net/liukuan73/article/details/78881008</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何针对高写入低查询es集群优化]]></title>
        <id>https://github.com/amendge/amendge.github.io/post/ru-he-zhen-dui-gao-xie-ru-di-cha-xun-es-ji-qun-you-hua/</id>
        <link href="https://github.com/amendge/amendge.github.io/post/ru-he-zhen-dui-gao-xie-ru-di-cha-xun-es-ji-qun-you-hua/">
        </link>
        <updated>2020-07-22T06:32:41.000Z</updated>
        <summary type="html"><![CDATA[<p>针对高并发写入的日志集群、告警集群做从日志写入、处理、集群优化提高写入吞吐量</p>
]]></summary>
        <content type="html"><![CDATA[<p>针对高并发写入的日志集群、告警集群做从日志写入、处理、集群优化提高写入吞吐量</p>
<!-- more -->
<p>概述:ELK现在已经成为大多数公司作为日志存储、告警的通用解决方案,目前我们现网除了业务日志走大数据之外，其他组件内部支持皆为elk存储告警.<br>
集群规模:<br>
es集群为 28节点 每个节点5.5T盘机械硬盘 存储数据约7天/55T 写入约12w/s</p>
<h1 id="高写入低查询集群">高写入低查询集群:</h1>
<p>向索引中插入数据时，文档首先被保存在内存缓存（in-memory buffer）中，同时将操作写入到translog中，此时这条刚插入的文档还不能被搜索到。默认1秒钟refresh一次，refresh操作会将文件写到操作系统的文件系统缓存中，并形成一个segment，refresh后文档可以被检索到。<br>
当flush的时候，所有segment被同步到磁盘，同时清空translog，然后生成一个新的translog,Lucene把每次生成的倒排索引叫做一个segment，也就是说一个segment就是一个倒排索引</p>
<p>##日志格式优化:<br>
日志格式/字段：<br>
日志格式统一采JSON，便于 ELK 解析处理。日志中的各个字段的值，都应该尽量使用 英文 ，不使用中文。<br>
日志具体字段：分为 基础数据 + 扩展数据。基础数据，是底层日志框架自带的，所有日志都需包含。扩展数据，不同类型的日志，包含不同的字段<br>
日志基础数据：</p>
<ul>
<li>hostname: string  主机名</li>
<li>hostip：string   主机ip</li>
<li>timestamp：date  日志产生时间(UTC 格式的日期)</li>
<li>module：string  服务名称</li>
<li>ret：int  状态码</li>
<li>cluster_tag：string   集群区分(环境变量$RUNENV)</li>
<li>calltime：int 耗时<br>
注意:基础字段可全部包含但必须有可囊括字段(如ret或calltime)<br>
日志扩展数据:</li>
<li>req\resp等请求体，扩展字段: TODO,需位于json第一层字段</li>
<li>stat类型日志，扩展字段: {  perf: {rss:xxx, oss:xxx} }</li>
<li>pipe类型日志，扩展字段: [ log:{rss:xxx, oss:xxx} ]</li>
<li>不带有type字段与logstash冲突导致日志写入失败</li>
</ul>
<h2 id="写入链路优化">写入链路优化:</h2>
<p>去除写入多余字段如：req\rep等<br>
压缩无需索引字段,做序列化转义压缩:如<br>
&quot;log&quot;: &quot;[{&quot;calltime&quot;:5,&quot;methodName&quot;:&quot;getStartNode&quot;,&quot;reqArgs&quot;:[&quot;5ee0fd60&quot;,&quot;START&quot;],&quot;result&quot;:{&quot;audioUrl&quot;:&quot;&quot;,&quot;name&quot;:&quot;开始&quot;,&quot;nodeId&quot;:1,&quot;replyContent&quot;:&quot;&quot;,&quot;toNodeIds&quot;:[2],&quot;type&quot;:&quot;start&quot;}},{&quot;calltime&quot;:6,&quot;methodName&quot;:&quot;getNodeById&quot;,&quot;reqArgs&quot;:[&quot;5ee0fd60&quot;,2],&quot;result&quot;:{&quot;audioUrl&quot;:&quot;http://aiui.xfyun.cn/index-aiui&quot;,&quot;name&quot;:&quot;摘机问候&quot;,&quot;nodeId&quot;:2,&quot;replyContent&quot;:&quot;摘机问候&quot;,&quot;toNodeIds&quot;:[3],&quot;type&quot;:&quot;robot&quot;}},{&quot;calltime&quot;:4,&quot;methodName&quot;:&quot;getNodeById&quot;,&quot;reqArgs&quot;:[&quot;5ee0fd60&quot;,3],&quot;result&quot;:{&quot;audioUrl&quot;:&quot;&quot;,&quot;name&quot;:&quot;用户任意说&quot;,&quot;nodeId&quot;:3,&quot;replyContent&quot;:&quot;&quot;,&quot;toNodeIds&quot;:[4],&quot;type&quot;:&quot;popple&quot;}},{&quot;calltime&quot;:4,&quot;methodName&quot;:&quot;getNextAnswerNodes&quot;,&quot;reqArgs&quot;:[&quot;5ee0fd60&quot;,{&quot;audioUrl&quot;:&quot;http://aiui.xfyun.cn/index-aiui&quot;,&quot;name&quot;:&quot;摘机问候&quot;,&quot;nodeId&quot;:2,&quot;replyContent&quot;:&quot;摘机问候&quot;,&quot;toNodeIds&quot;:[3],&quot;type&quot;:&quot;robot&quot;}],&quot;result&quot;:[4]}]&quot;,</p>
<h1 id="es-cluster集群优化">Es cluster集群优化:</h1>
<h2 id="机器部署">机器部署:</h2>
<p>日志数据非业务重要可以试试RAID0,写入性能相对RAID1可以提升25-30%</p>
<h2 id="针对translog优化">针对translog优化:</h2>
<p>translog.flush_threshold_size： 1024mb<br>
translog.durability ==&gt;async异步方式同步</p>
<h2 id="索引刷新优化">索引刷新优化</h2>
<p>部分索引非实时搜索.想优化索引速度而不是近实时搜索,降低索引的刷新频率<br>
&quot;refresh_interval&quot;: &quot;30s&quot;</p>
<h2 id="分片副本优化">分片副本优化</h2>
<p>分片和副本:针对大索引+高写入+存储大小大于150GB<br>
number_of_shards 10<br>
number_of_replicas 1 or 0<br>
根据索引的重要程度+查询速度要求 有无副本</p>
<p>高写入+存储大小大于150GB + 低查询速度 有些无副本 并且分片 略小于节点数</p>
<h2 id="增大静态配置参数">增大静态配置参数</h2>
<p>indices.memory.index_buffer_size (默认10%)<br>
示例:索引10shards,1副本,日约3.6亿条，存储量1T左右,设置成30%提高了约10%写入性能</p>
<h2 id="避免出现热点节点">避免出现热点节点</h2>
<p>routing.allocation.total_shards_per_node&quot;:&quot;2&quot;</p>
<h2 id="调整bulk线程池和队列">调整bulk线程池和队列</h2>
<h2 id="部分高频索引自建templates">部分高频索引自建templates：</h2>
<p>写入体较大的索引,如某条日志接近上千行,不建议往es中进行写入,因字段较多，或者日志体中含有无法解析的json体或者dict体。虽然第一层字段类型被定义为text或者数组体。但是内部字段还是会被分离，被mapping.后续大量日志写入的时候就会进行大量的mapping,日志量和日志体都过大或导致merge的时候耗时高，同时进行新旧gc的时候也会耗时很大。也容易导致节点oom</p>
<h1 id="查询优化">查询优化:</h1>
<p>1.通过监控分析确定ES集群节点负载,对高负载节点做定向索引分解和必要时重启散压力操作<br>
2.出现热点节点可试图通过Cerebro 或者自身es-head进行索引分片调整<br>
3.查询时尽量勿选择时间长、通配字符查询、分片数量大</p>
<h1 id="总结过程">总结过程</h1>
<p>规范日志写入格式、日志写入前进行序列化、固化日志内固定字段用于后续告警<br>
升级日志集群版本和新的告警对齐、日志机器统一化、模板化、集群数据节点/协调节点分离<br>
优化集群配置：调整线程池和队列、translog异步优化、索引等级刷新优化、索引分类副本优化、索引<br>
优化写入链路:去除写入多余字段(req/resp等)、压缩字段内部字典/数组日志、做性能日志的耗时丢弃、按照特定规则分割<br>
索引优化部分重要索引优化副本、自建templates、定义好mapping规则<br>
查询优化: 热点数据进行内存缓存快速查询，集群部分节点做冷数据存储,大于3天的数据抛入冷节点，<br>
消费优化: 模板化单key消费模板与cicd打通,由物理机多机器部署升级至容器化部署<br>
缓存优化：因缓存组件无法更换，由单节点redis升级至temproxy多节点分发，针对redis缓存队列配置和写入问题做了优化</p>
<h1 id="总结">总结:</h1>
<p>1.如果有能力上SSD+内存大小大于数据60%,可以忽略上述所有<br>
2.如果针对磁盘性能问题可以试试磁盘硬件方面RAID0<br>
3.整体链路优化需要从入口、过滤、写入都需要进行优化<br>
4.最好的优化方法是简于形,规于心</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【监控】监控到底要监控哪些东西]]></title>
        <id>https://github.com/amendge/amendge.github.io/post/jian-kong-jian-kong-dao-di-yao-jian-kong-na-xie-dong-xi/</id>
        <link href="https://github.com/amendge/amendge.github.io/post/jian-kong-jian-kong-dao-di-yao-jian-kong-na-xie-dong-xi/">
        </link>
        <updated>2020-03-06T02:49:52.000Z</updated>
        <summary type="html"><![CDATA[<p>😎对于运维来说，老生常谈的就是监控.<br>
那么我们该监控哪些东西才能才能及时的发现问题,不会背锅，才不会事后弥补呢</p>
]]></summary>
        <content type="html"><![CDATA[<p>😎对于运维来说，老生常谈的就是监控.<br>
那么我们该监控哪些东西才能才能及时的发现问题,不会背锅，才不会事后弥补呢</p>
<!-- more -->
<h1 id="名人名言">名人名言</h1>
<ul>
<li>
<p>监控大法好，谁也跑不了</p>
</li>
<li>
<p>业务有问题，监控帮助您！</p>
<p>架构梳理图:<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617864679339.png" alt="" loading="lazy"></p>
</li>
</ul>
<p>从以上图可以看出作者这边把监控分为从入口到底部的一个分层:</p>
<ul>
<li>服务监控</li>
<li>中间件监控</li>
<li>业务监控</li>
<li>入口监控</li>
<li>接入监控</li>
</ul>
<h2 id="服务监控">服务监控</h2>
<p>针对服务器的基础监控:<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617864869984.png" alt="" loading="lazy"></p>
<h2 id="中间件容器">中间件/容器</h2>
<p>针对服务依赖中间件/载体：<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617864887255.png" alt="" loading="lazy"></p>
<h2 id="k8s集群">K8S集群</h2>
<p>当前K8S已经有很多公司使用中,对于它的监控也是至关重要<br>
<img src="https://github.com/amendge/amendge.github.io/post-images/1617864891752.png" alt="" loading="lazy"></p>
<h2 id="业务监控集成">业务监控(集成)</h2>
<p>如果有公司使用proemtheus的可以试试在不影响服务性能的情况下继承Prometheus客户端，官方提高了不同语言的客户端</p>
<ul>
<li>golang</li>
<li>java(jmx_exporter\pom)</li>
<li>python等等</li>
</ul>
<h2 id="业务监控日志">业务监控(日志)</h2>
<p>针对组件日志监控一般需要规范格式.</p>
<ul>
<li>nginx日志</li>
<li>组件日志</li>
<li>请求日志</li>
<li>链路日志<br>
一般组件日志常用状态码或者耗时进行监控，而组件业务日志包含很多敏感信息或不同类型,常用大数据聚合统计监控</li>
</ul>
<h2 id="调用监控">调用监控</h2>
<p>针对业务做链路拨测</p>
<ul>
<li>全链路拨测</li>
<li>重点客户拨测</li>
<li>全业务模块拨测</li>
<li>核心组件拨测</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[首序]]></title>
        <id>https://github.com/amendge/amendge.github.io/post/welcome/</id>
        <link href="https://github.com/amendge/amendge.github.io/post/welcome/">
        </link>
        <updated>2019-05-14T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏 欢迎使用来到Amend的个人博客！<br>
✍️ 这里用来记录我的技术攻略、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏 欢迎使用来到Amend的个人博客！<br>
✍️ 这里用来记录我的技术攻略、知识、笔记、创意... ...</p>
<!-- more -->
<h2 id="talk-is-sheep-show-me-code">talk is sheep show me code👇</h2>
<p><a href="https://github.com/gecailong">Github</a><br>
<a href="http://www.noalert.cn">blog</a></p>
<h2 id="特性">特性👇</h2>
<p>📝 从业年限4年</p>
<p>🌉 从业方向监控为主+</p>
<p>🏷️ 我的标签:监控、告警、运维、小帅比</p>
<p>📋 这里呢记录的不仅是我自身的钻研、还有很多大神们的技术积累</p>
<p>💻 学过python\java\c++\golang，但是略懂python</p>
<p>🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 查看我的分享和创作来支持你的工作</p>
<p>🌱 当然我还很年轻，有很多不足，但请相信，我会不停向前 🏃</p>
<p>未来，我一定会成为你离不开的伙伴</p>
<p>😘 Enjoy~</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>